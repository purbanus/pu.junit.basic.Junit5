package pu.junit.basicJunit5;

/**
 * Dit komt uit https://www.baeldung.com/junit-5
 */
import static org.junit.jupiter.api.Assertions.*;
import static org.junit.jupiter.api.Assumptions.*;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Stream;

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.DynamicTest;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestFactory;

public class BasicJunit5Tests
{
public static void log( String aMessage )
{
	System.out.println( aMessage );
}
/**
4.1. @BeforeAll and @BeforeEach
Below is an example of the simple code to be executed before the main test cases:
It’s important to note that the method with the @BeforeAll annotation needs to be static, otherwise the code won’t compile.
*/
@BeforeAll
static void setup() {
    log("@BeforeAll - executes once before all test methods in this class");
}

@BeforeEach
void init() {
    log("@BeforeEach - executes before each test method in this class");
}

/**
 * 4.2. @DisplayName and @Disabled
Now let’s move to new test-optional methods:
 */
@DisplayName("Single test successful") // Dit wijgit de tekst van de Junit test, op het scherm
@Test
void testSingleSuccessTest() {
    log("Success");
}

@Test
@Disabled("Not implemented yet")
void testShowSomething() 
{
    log("Disabled test");
}
/**
4.3. @AfterEach and @AfterAll
Finally, let’s discuss the methods connected to operations after test execution:
*/
@AfterEach
void tearDown() {
    log("@AfterEach - executed after each test method.");
}

@AfterAll
static void done() {
    log("@AfterAll - executed after all test methods.");
}
/**
5.1. Assertions
Assertions have been moved to org.junit.jupiter.api.Assertions, and have been significantly improved. As mentioned earlier, we can now use lambdas in assertions:
Although the example below is trivial, one advantage of using the lambda expression for the assertion message is that it’s lazily evaluated, which can save time and resources if the message construction is expensive.
*/

@Test
void lambdaExpressions() 
{
    List<Integer> numbers = Arrays.asList(1, 2, 3);
    assertTrue(numbers.stream()
      .mapToInt(Integer::intValue)
      .sum() > 5, () -> "Sum should be greater than 5");
}
/**
It’s also now possible to group assertions with assertAll(), which will report any failed assertions 
within the group with a MultipleFailuresError:
This means it’s now safer to make more complex assertions, as we’ll be able to pinpoint the exact location of any failure.
*/
 @Test
 void groupAssertions() {
     int[] numbers = {0, 1, 2, 3, 4};
     assertAll("numbers",
         () -> assertEquals(numbers[0], 0),
         () -> assertEquals(numbers[3], 3),
         () -> assertEquals(numbers[4], 4)
     );
 }
/**
 * 5.2. Assumptions

Assumptions are used to run tests only if certain conditions are met. This is typically used for external conditions that are required for the test to run properly, but which aren’t directly related to whatever is being tested.
We can declare an assumption with assumeTrue(), assumeFalse(), and assumingThat():

if an assumption fails, a TestAbortedException is thrown and the test is simply skipped.
Assumptions also understand lambda expressions.
 */
@Test
void trueAssumption() {
    assumeTrue(5 > 1);
    assertEquals(5 + 2, 7);
}

@Test
void falseAssumption() {
    assumeFalse(5 < 1);
    assertEquals(5 + 2, 7);
}

@Test
void assumptionThat() {
    String someString = "Just a string";
    assumingThat(
        someString.equals("Just a string"),
        () -> assertEquals(2 + 2, 4)
    );
}
/**
6. Exception Testing
There are two ways of exception testing in JUnit 5, both of which we can implement using the assertThrows() method:
*/
@Test
void shouldThrowException() {
    Throwable exception = assertThrows(UnsupportedOperationException.class, () -> {
      throw new UnsupportedOperationException("Not supported");
    });
    assertEquals("Not supported", exception.getMessage());
}

@Test
void assertThrowsException() {
    String str = null;
    assertThrows(IllegalArgumentException.class, () -> {
      Integer.valueOf(str);
    });
}
/**
 * 7. Test Suites zie AllUnitTests.class en SomeUnitTests.class
*/

/**
8. Dynamic Tests

The last topic that we want to introduce is JUnit 5’s Dynamic Tests feature, which allows us to declare and run test cases generated 
at run-time. Contrary to Static Tests, which define a fixed number of test cases at the compile time, Dynamic Tests allow us to define 
the test cases dynamically in the runtime.
Dynamic tests can be generated by a factory method annotated with @TestFactory. Let’s have a look at the code:
This example is very straightforward and easy to understand. We want to translate words using two ArrayLists, named in and out, 
respectively. The factory method must return a Stream, Collection, Iterable, or Iterator. In our case, we chose a Java 8 Stream.
Please note that @TestFactory methods must not be private or static. The number of tests is dynamic, and it depends on the ArrayList size.
*/
List<String> in = Arrays.asList( "pipo", "koeie" );
List<String> out = Arrays.asList( "dikke", "deur" );
@TestFactory
Stream<DynamicTest> translateDynamicTestsFromStream() {
    return in.stream()
      .map(word ->
          DynamicTest.dynamicTest("Test translate " + word, () -> {
            int id = in.indexOf(word);
            assertEquals(out.get(id), translate(word));
          })
    );
}
@Test
public void undynamicTest()
{
	int x = 0;
	for ( String word : in )
	{
		assertEquals( out.get(  x  ), translate( word ) );
		x++;
	}
}
private String translate( String aWord )
{
	if ( aWord.equals( "pipo" ) )
	{
		return "dikke";
	}
	if ( aWord.equals( "koeie" ) )
	{
		return "deur";
	}
	return "Not foud";
}




}
